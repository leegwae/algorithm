# Greedy Algorithm

**탐욕법(Greedy Algorithm)**의 패러다임은 다음과 같이 볼 수 있다.

1. 문제를 여러 개의 부분 문제로 나눈다.
2. 각 문제를 풀 때마다 당장 최선의 결과를 선택한다.



## 탐욕법을 적용할 수 있는 문제들

탐욕법을 적용하여 풀이할 수 있는 문제들은 아래와 같다.

1. **최적 부분 구조(Optiomal Substructure)**를 가진 문제
2. **탐욕 선택 속성(Greedy Choice Property)**를 가진 문제



문제가 위 두 조건을 만족한다면 **최적해**를 얻을 수 있으며, 만족하지 못해도 **근사해**를 찾을 수 있다.



### 최적 부분 구조

문제의 가장 좋은 해결 방법이 부분 문제의 가장 좋은 해결 방법으로 구성된 것을 뜻한다.

[다이나믹 프로그래밍 - 최적 부분 구조](https://github.com/leegwae/algorithms/blob/main/dynamic-programming.md#%EC%B5%9C%EC%A0%81-%EB%B6%80%EB%B6%84-%EA%B5%AC%EC%A1%B0) 참고



### 탐욕 선택 속성

앞 단계의 선택이 이후 단계의 선택에 영향을 주지 않는 것을 뜻한다.



## 탐욕법과 동적 계획법의 차이

- 동적 계획법은 부분 문제에 대하여 최선의 답을 바탕으로 전체 문제의 답을 구한다.
- 탐욕법은 각 단계에서 당장 최선의 결과를 택하고, 문제의 크기를 줄여나간다. 따라서 동적 계획법에 비하여 해를 구하는 시간이 빠르다.



## 탐욕법의 동작

탐욕법으로 문제를 풀기 위해 다음과 같은 단계가 필요하다.

1. 문제를 작은 부분 문제로 나누기
2. 부분 문제마다 어떤 우선순위로 선택할지 결정하기
3. 탐욕법을 적용할 수 있는 문제인지 확인하기
4. 구현하기



## 탐욕법으로 풀 수 있는 문제들

### 예: A를 B로 만들기

> A와 B가 주어진다. A에 적용할 수 있는 연산이 다음과 같을 때, A를 B로 만드는 최소 연산 횟수를 구하라.

A를 B로 만들기 위해 탐색해야하는 경우의 수가 매우 많다면, B를 A로 만드는 문제로 바꾸어 경우의 수를 좁힐 수 있다.

[예: A와_B.py](https://github.com/leegwae/problem-solving/blob/main/greedy/A%EC%99%80_B.py)

[예: 두_배\_더하기.py](https://github.com/leegwae/problem-solving/blob/main/greedy/%EB%91%90_%EB%B0%B0_%EB%8D%94%ED%95%98%EA%B8%B0.py)



### 예: 분할 가능 배낭 문제

> 배낭에 최대 `n`(kg)만큼 넣을 수 있다. 각 물건마다 `k`(kg)의 무게와 `w`의 가치가 주어지며, 물건은 쪼갤 수 있다. (가령, 4kg의 벽돌은 1kg의 벽돌 4개로 쪼갤 수 있다.)
>
> 배낭에 물건을 넣었을 때 배낭 속 물건들의 가치의 합이 최대가 되는 경우를 구한다.

**분할 가능 배낭 문제(Fractional knapsack Problem)**는 배낭 문제 중 짐을 쪼갤 수 있는 경우의 문제를 의미한다. 이 문제는 탐욕법으로 풀 수 있다.

```python
pack = [(kg당 가치, 총가치, 총무게)]

def fractional_knapsack():
    # kg 당 무게로 가장 무거운 순으로 정렬
    pack.sort(reverse=True, key=lambda x: x[0])
    
    result = 0
    i = 0
    while True:
        cpk, c, k = pack[i]
        if n >= k:
            result += c
            n -= k
            i += 1
        else:
            result += cpk * n
            break
        
    return result
```

이와 달리 짐을 쪼갤 수 없다면 **0-1 배낭 문제(0-1 Knapsack Problem)**이라고 한다. 이 문제는 동적 계획법으로 풀 수 있다.



### 예: 동전 문제

> 동전이 `n` 종류가 주어진다. 또한 동전은 모두 다른 동전과 배수 관계를 가진다. `k`원을 만들기 위해 필요한 최소한의 동전 개수는 몇 개인가?

동전들이 서로 배수 관계이기 때문에 그리디 알고리즘을 적용할 수 있다. 가령, 두 개의 50원은 한 개의 100원으로 바꿀 수 있다. 그러므로 분할 가능 배낭 문제에서 가장 큰 짐부터 넣어보았듯이 가장 큰 동전부터 넣어가며 문제를 푼다.

[예: 동전 1.py](https://github.com/leegwae/problem-solving/blob/main/greedy/%EB%8F%99%EC%A0%84%201.py)

한편, 동전들이 서로 배수 관계가 아니라면 동적 계획법을 적용해야한다.



### 기타: 정렬과 우선순위 큐의 사용

대개 탐욕법 문제들은 정렬을 사용하여 `최소...` 혹은 `최대...`를 구하는 문제이다. 단, 정렬의 시간복잡도가 커서 시간 초과가 발생한다면 우선순위 큐 자료구조를 사용하여 `O(logn)`의 시간 복잡도로 삽입, 삭제 연산을 수행할 수 있다.

[예: 카드_정렬하기.py](https://github.com/leegwae/problem-solving/blob/main/greedy/%EC%B9%B4%EB%93%9C_%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0.py)



