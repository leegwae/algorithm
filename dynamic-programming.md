# Dynamic Programming

**동적 계획법(Dynamic Progamming)**의 패러다임은 다음과 같이 볼 수 있다.

1. 문제를 여러 개의 부분 문제로 나눈다.
2. 중복되는 부분 문제는 매번 새로 계산하지 않고, 계산 결과를 저장해놓았다가 다시 사용한다.



## 동적 계획법을 적용할 수 있는 문제들

동적 계획법을 적용하여 풀이할 수 있는 문제들은 아래와 같다.

1. **최적 부분 구조(Optimal Substructure)**를 가진 문제
2. **중복되는 부분 문제(overlapping subproblems)**를 가진 문제
3. **메모이제이션(memoization)**을 적용할 수 있는 문제



### 최적 부분 구조

- **최적 부분 구조(Optimal Substructure)**: 문제를 해결하는 최적의 방법이 부분 문제를 해결하는 최적의 방법들로 구성되는 경우를 뜻한다.
- 예를 들어 `A-B-C`로 이어져있을 때 (1) `A`에서 `C`로 가는 최단 경로를 찾는다고 하자. (2) `A`에서 `B`로 가는 경로가 몇 가지 있고, (3) `B`에서 `C`로 가는 경로도 몇 가지 있다. 동적 계획법을 적용한다면 다음과 같이 해결할 수 있다.

```python
(1)을 해결하는 최적의 방법 = (2)를 해결하는 최적의 방법 + (3)을 해결하는 최적의 방법
(A-C의 최단 경로) = (A-B의 최단 경로) + (B-C)의 최단 경로
```



### 중복되는 부분 문제

- **중복되는 부분 문제(overlapping subproblems)**: 하나의 문제를 여러 부분으로 나누었을 때, 두 번 이상 계산되는 부분 문제를 의미한다.



#### 예: 피보나치 수열

피보나치 수열을 계산하는 함수 `F`가 있다.

```python
def F(n):
    if n == 0 or n == 1:
        return n
    
    return F(n-2) + F(n-2)
```

`F(5)`를 계산하기 위해서 `F(1)`과 `F(2)`, `F(3)`이 여러 번 호출되는 것을 볼 수 있다.

```
F(5) = F(3) + F(4)
		|-- F(3) = F(1) + F(2)	|-- F(4) = F(2) + F(3)
													|-- F(3) = F(1) + F(2)
```



### 메모이제이션과 참조적 투명성

- **메모이제이션(memoization)**: 한 번 계산한 값을 저장해두었다가 재활용하는 것이다.
- **참조적 투명성(referential transparency)**: 입력값이 같다면 함수가 언제나 같은 반환값을 내는 것을 의미한다.
- 메모이제이션을 적용하기 위해서 함수는 참조적 투명성을 가져야 한다. 피보나치 수열을 계산할 때 `F(2)`를 저장해놓았다면 그 값이 언제나 같길 원할 것이다,



## 동적 계획법의 방법론

동적 계획법에는 두가지 방법론이 있다.

1. 상향식(Bottom-up)
2. 하향식(Top-Down)



### 상향식

- **상향식(bottom-up)**: 더 작은 하위 문제부터 계산한 후, 이 문제들의 계산 결과를 이용하여 더 큰 문제를 계산한다.
  - **타뷸레이션(tabulation)**이라고도 한다.
  - 반복문을 사용한다.
  - 함수 호출로 인한 오버헤드가 없다: 시간과 메모리를 더 절약할 수 있다.



### 하향식

- **하향식(top-down)**: 더 큰 문제를 호출한 후, <u>하위 문제가 계산되었는지 확인하며</u> 문제를 계산한다.
  - **메모이제이션(memoization)**이라고도 한다.
  - 재귀를 사용한다.
  - 가독성이 좋으며, 본래의 점화식의 형태를 따르므로 자연스럽다.



## 동적 계획법으로 알고리즘 설계하기

동적 계획법으로 문제를 푸려면 크게 세 단계를 거쳐야 한다.

1. 문제를 정의하고 더 작은 부분 문제로 나누기
2. 동적 계획법을 적용할 수 있는 문제인지 확인하기
3. 방법론 선택하고 구현하기



여기서는 `피보나치 수열`을 예시로 한다.



### 1. 문제를 정의하고 더 작은 부분 문제로 나누기

> 피보나치 수열에서 `n`번째에 있는 항을 구하시오.

위와 같은 문제가 주어진다고 하자.

1. 문제 `f(n)` 정의하기

문제 `f(n)`은 다음과 같이 정의할 수 있다.
$$
f(n)=\mbox{피보나치 수열에서 }n\mbox{번째에 있는 항}
$$

2. `f(n)`을 더 작은 부분 문제로 나누기

피보나치 수열을 `점화식`으로 표현하면 아래와 같다.
$$
f(n)=
\begin{cases}
0 & (n=0) \\
1 & (n=1) \\
f(n-2) + f(n-1) & (n\ge 1)
\end{cases}
$$


### 2. 동적 계획법을 적용할 수 있는 문제인지 확인하기

동적 계획법을 적용할 수 있는 문제는 [다음](https://github.com/leegwae/algorithms/blob/main/Dynamic%20Programming.md#%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EB%93%A4)과 같은 조건을 만족해야한다.

1. 최적 부분 구조를 가져야 한다.
2. 중복되는 부분 문제를 가져야한다.
3. 함수는 참조적 투명 함수여야 한다.



`점화식`을 보면 이 문제는 동적 계획법을 적용할 수 있는 문제라는 것을 알 수 있다.

1. 최적 부분 구조를 가진다: `f(n)`을 해결하는 방법은 `f(n-2)`와 `f(n-1)`를 해결하는 방법으로 구성되어있다.
2. 중복되는 부분 문제를 가진다: `f(n)`을 호출한다면 어떤 `k(k < n)`에 대하여 `f(k)`는 여러 번 호출된다.
3. 참조적 투명 함수이다: `f(n)`은 언제 어디서 호출하든 같은 값을 반환한다.



### 3. 방법론 선택하고 구현하기

#### 상향식(bottom-up)

```python
def f(n):
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

- 반복문을 사용하여 더 작은 문제부터 풀이한다: `i`는 `2`부터 `n`까지 오름차순으로 올라가고 있다.



#### 하향식(top-down)

```python
def f(n):
    if n <= 1:
        return n
    
    if dp[n]:
        return dp[n]
    
    dp[n] = f(n - 1) + f(n - 2)
    return dp[n]
```

- 재귀를 사용하여 더 큰 문제부터 호출한다: `f(n)`을 호출한 후 `f(n - 1)`와 `f(n - 2)`을 호출한다. 중복되는 부분 문제라는 점을 이용하여 `dp[n]`이 저장되어 있다면 그 결과를 반환하고 있다.



### 동적 계획법으로 알고리즘 구현하기

동적 계획법으로 구현한 함수는 다음과 같은 구조를 가진다.

1. 기저 사례
2. 메모이제이션
3. 로직
4. 초기화

```python
def f(n):
    # 기저 사례
    if (...) return ...;
	
    # 메모이제이션
	if dp[n] != 0:
        return dp[n]
    
    # 로직: 값을 계산한다.
    dp[n] = ....

    return dp[n]

if __name__ == "__main__":
    # 배열을 0으로 초기화
    dp = [0] * MAX_SIZE
```



#### 1. 기저 사례

```python
if n == 0:
    return 0
if n == 1:
    return 1
```

- 기저 사례를 먼저 정의하여, 범위를 벗어나지 않도록 한다.



#### 2. 메모이제이션

```python
if dp[n]:
    return dp[n]
```

- 이미 계산하여 저장한 값이 있다면, 그 값을 반환한다.



#### 3. 로직

```python
dp[n] = f(n - 1) + f(n - 2)
```

- 값을 계산한다.



#### 4. 초기화

```python
from collections import defaultdict

if __name__ == "__main__":
    dp = defaultdict(int)
```

- 메모이제이션을 위해 결과를 저장할 딕셔너리를 초기화한다.



피보나치 수열의 하향식 전체 코드는 아래와 같다.

```python
from collections import defaultdict

def f(n):
    # ========= 기저 사례 ==============
    if n <= 1:
        return n
    
    # ========= 메모이제이션 ============
    if dp[n]:
        return dp[n]
    
    # ========== 로직 ==================
    dp[n] = f(n - 1) + f(n - 2)
    return dp[n]

if __name__ == "__main__":
	N = int(input())
    # ========== 초기화 =================
    dp = defaultdict(int)
    
    print(f(N))
```



## 동적 계획법으로 풀 수 있는 문제들

### 예: 0-1 배낭 문제

> 배낭에 최대 `n`(kg)만큼 넣을 수 있다. 각 물건마다 `k`(kg)의 무게와 `w`의 가치가 주어지며, 물건은 쪼갤 수 없다. (가령, 4kg의 벽돌은 1kg의 벽돌 4개로 쪼갤 수 없다.)

**0-1 배낭 문제(0-1 Knapsack Problem)**은 배낭 문제 중 짐을 쪼갤 수 없는 경우를 의미한다. 이 문제는 동적 계획법으로 풀 수 있다.

[예: 평범한_배낭.py](https://github.com/leegwae/problem-solving/blob/main/dp/%ED%8F%89%EB%B2%94%ED%95%9C_%EB%B0%B0%EB%82%AD.py)

이와 달리 짐을 쪼갤 수 있다면 **분할 가능 배낭 문제(Fractional knapsack Problem)**라고 한다. 이 문제는 그리디 알고리즘으로 풀 수 있다.



### 예: 동전 문제

> 동전이 `n` 종류 주어진다. `k`원을 만들기 위해 필요한 최소한의 동전 개수는 몇 개인가?

0-1 배낭 문제에서처럼 모든 동전을 넣어보며 최선의 결과를 도출한다.

[예: 동전 2.py](https://github.com/leegwae/problem-solving/blob/main/dp/%EB%8F%99%EC%A0%84%202.py)
