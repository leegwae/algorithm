# Sorting Algorithms

- **정렬 알고리즘(Sorting Algorithm)**은 원소들을 일정한 순서대로 나열하는 알고리즘이다.



## 정렬 알고리즘의 평가 기준

정렬 알고리즘의 평가 기준은 다음과 같다.

1. 비교 횟수가 많은지 적은지
2. 이동 횟수가 많은지 적은지



## 정렬 알고리즘과 관련한 용어

### 안정적인 정렬

- 정렬 알고리즘이 **안정적(stable)**이다: 동일한 키 값을 갖는 요소들의 상대적인 위치가 정렬 후에도 바뀌지 않는 것을 뜻한다.

```
arr = [30, 30, 10, 20]
sorted = [10, 20, 30, 30]
```

가령 `arr[0]`의 30을 `A`, `arr[1]`의 30을 `B`라고 할 때 정렬 후 `A - B` 순이 아니라 `B - A`순으로 불필요하게 위치가 바뀔 경우 안정되지 않은 정렬이다.

### 제자리 정렬

- **제자리 정렬(in-place sorting)**: 정렬하려는 배열 외에는 다른 추가 메모리가 필요하지 않는 정렬을 뜻한다.



## 정렬 알고리즘의 종류

- [선택 정렬(Selection Sort)](https://github.com/leegwae/algorithms/blob/main/selection-sort.md)
- [삽입 정렬(Insertion Sort)](https://github.com/leegwae/algorithms/blob/main/insertion-sort.md)
- [버블 정렬(Bubble Sort)](https://github.com/leegwae/algorithms/blob/main/bubble-sort.md)
- [퀵 정렬(Quick Sort)](https://github.com/leegwae/algorithms/blob/main/quick-sort.md)
- [힙 정렬(Heap Sort)](https://github.com/leegwae/algorithms/blob/main/heap-sort.md)
- [합병 정렬(Merge Sort)](https://github.com/leegwae/algorithms/blob/main/merge-sort.md)

| 정렬 알고리즘 | 안정 정렬   | 제자리 정렬      |
| ------------- | ----------- | ---------------- |
| 선택 정렬     | 불안정 정렬 | 제자리 정렬      |
| 삽입 정렬     | 안정 정렬   | 제자리 정렬      |
| 버블 정렬     | 안정 정렬   | 제자리 정렬      |
| 퀵 정렬       | 불안정 정렬 | 제자리 정렬      |
| 힙 정렬       | 불안정 정렬 | 제자리 정렬      |
| 병합 정렬     | 안정 정렬   | 제자리 정렬 아님 |



## 정렬 알고리즘의 복잡도

| 정렬 알고리즘 | 시간 복잡도(최선) | 시간 복잡도(평균) | 시간 복잡도(최악) | 공간 복잡도(최악) |
| ------------- | ----------------- | ----------------- | ----------------- | ----------------- |
| 선택 정렬     | O(n^2)            | O(n^2)            | O(n^2)            | O(1)              |
| 삽입 정렬     | O(n)              | O(n^2)            | O(n^2)            | O(1)              |
| 버블 정렬     | O(n)              | O(n^2)            | O(n^2)            | O(1)              |
| 퀵 정렬       | O(nlogn)          | O(nlogn)          | O(n^2)            | O(logn)           |
| 힙 정렬       | O(nlogn)          | O(nlogn)          | O(nlogn)          | O(1)              |
| 합병 정렬     | O(nlogn)          | O(nlogn)          | O(nlogn)          | O(n)              |



## 스터디

- 선택 정렬이 버블 정렬보다 좋은 점을 하나 말씀해주세요

  선택 정렬은 순회 한 번 할 때 swap 한 번 하지만 버블 정렬은 순회 한 번 할 때 인접한 요소를 계속 swap한다.

- 퀵 정렬에서 최악의 경우는 어떤 경우인가?

  피벗 값을 최솟값이나 최댓값으로 지정하는 경우이다.

- 퀵 정렬에서 역순으로 정렬되어 있는 경우에도 최선의 경우가 나올 수 있을까?

  피벗의 값을 적절히 설정하여 부분 배열이 최대한 균등하게 쪼개어지도록 하면 된다. 중간값을 피벗으로 선정하는 것이 가장 적절하다.

- 병합 정렬과 퀵 정렬의 차이점은 무엇인가?

  병합 정렬은 최소 단위까지 쪼갠 후 합치지만 퀵 정렬은 쪼개면서 정렬한다. 병합 정렬은 피벗 없이 균등하게 부분 배열을 쪼개고 퀵 정렬은 피벗을 기준으로 비균등하게 부분 배열을 쪼갠다.

- 병합 정렬이 퀵 정렬보다 좋은 점은?

  병합 정렬은 모든 경우에서 O(nlogn)의 시간 복잡도를 보장한다. 퀵 정렬은 최악의 경우 O(n^2)의 시간 복잡도를 요구한다.

- 병합 정렬과 퀵 정렬은 왜 평균적으로 O(nlogn)의 시간 복잡도를 요구하나요?

  두 정렬 알고리즘 모두 분할과 정복 기법을 사용하여 배열을 두 개의 부분 배열로 나누어 정렬하기 때문이다.

- 삽입, 버블, 선택 정렬을 swap이 많이 발생하는 순서로 나열해주세요

  버블 - 삽입 - 선택 순으로 많이 발생한다.

