# Floyd-Warshall Algorithm

**플로이드-워셜 알고리즘(Floyd-Warshall Algorithm)**은 모든 쌍 최단 거리 알고리즘이다. 동적 계획법을 사용한다.



## 플로이드-워셜 알고리즘의 동작

정점 `u`와 `v`를 잇는 경로가 거쳐가는 정점들을 경유점이라고 하자. 정점 `u`와 `v`를 잇는 최단 경로는 그래프의 어떤 정점 `x`를 경유할 수도, 그러지 않을 수 있다.

1. `x`를 경유하지 않는 경우: 최단 경로는 `x`를 제외한 정점들만을 경유점으로 사용한다.
2. `x`를 경유하는 경우: 최단 경로는 `u`에서 `x`로 가는 최단 경로 + `x`에서 `v`로 가는 최단 경로이다. 또한 각각의 부분 경로는 `x`를 경유하지 않는다.

두 경우 모두 `x`를 경유점으로 사용하지 않는 경로로 나타낼 수 있다.

```python
# 정점 0...x까지를 경유점으로 사용하여 정점 u에서 v로 가는 최단 경로
f(x, u, v) = min(
    f(x - 1, u, v),
    f(x - 1, u, x) + f(x - 1, x, u)
)
```



## 플로이드-워셜 알고리즘의 구현

[플로이드.py](https://github.com/leegwae/problem-solving/blob/main/graph/floyd/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C.py)

```python
# graph[u][v] = 정점 u부터 v 까지 최단 경로의 거리
for k in range(1, N + 1):
    graph[k][k] = 0
    for i in range(1, N + 1):
        for j in range(1, N + 1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])
```



## 플로이드-워셜 알고리즘의 복잡도

정점의 개수를 `N`개라고 하자.

- 시간 복잡도: 삼중 반복문을 도므로 `O(N^3)`
- 공간 복잡도: 기본적으로 `O(N^3)`이다(`graph[k][u][v]`). 그러나 1번째 정점부터 k번째 정점을 경유점으로 가지는 최단 경로는 1번째 정점부터 k-1번째 정점을 경유점으로 가지는 최단 경로 값을 사용하므로 슬라이딩 윈도우 기법을 적용하여 `O(N^2)`으로 줄일 수 있다(`graph[u][v]`).
