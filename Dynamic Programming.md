# Dynamic Programming

**동적 계획법(Dynamic Progamming)**의 패러다임은 다음과 같이 볼 수 있다.

1. 문제를 여러 개의 부분 문제로 나눈다.
2. 중복되는 부분 문제는 매번 새로 계산하지 않고, 계산 결과를 저장해놓았다가 다시 사용한다.



## 동적 계획법을 적용할 수 있는 문제들

동적 계획법을 적용하여 풀이할 수 있는 문제들은 아래와 같다.

1. **최적 부분 구조(Optimal Substructure)**를 가진 문제
2. **중복되는 부분 문제(overlapping subproblems)**를 가진 문제
3. **메모이제이션(memoization)**을 적용할 수 있는 문제



### 최적 부분 구조

- **최적 부분 구조(Optimal Substructure)**: 문제를 해결하는 최적의 방법이 부분 문제를 해결하는 최적의 방법들로 구성되는 경우를 뜻한다.
- 예를 들어 `A-B-C`로 이어져있을 때 (1) `A`에서 `C`로 가는 최단 경로를 찾는다고 하자. (2) `A`에서 `B`로 가는 경로가 몇 가지 있고, (3) `B`에서 `C`로 가는 경로도 몇 가지 있다. 동적 계획법을 적용한다면 다음과 같이 해결할 수 있다.

```python
(1)을 해결하는 최적의 방법 = (2)를 해결하는 최적의 방법 + (3)을 해결하는 최적의 방법
(A-C의 최단 경로) = (A-B의 최단 경로) + (B-C)의 최단 경로
```



### 중복되는 부분 문제

- **중복되는 부분 문제(overlapping subproblems)**: 하나의 문제를 여러 부분으로 나누었을 때, 두 번 이상 계산되는 부분 문제를 의미한다.



#### 예: 피보나치 수열

피보나치 수열을 계산하는 함수 `F`가 있다.

```python
def F(n):
    if n == 0 or n == 1:
        return n
    
    return F(n-2) + F(n-2)
```

`F(5)`를 계산하기 위해서 `F(1)`과 `F(2)`, `F(3)`이 여러 번 호출되는 것을 볼 수 있다.

```
F(5) = F(3) + F(4)
		|-- F(3) = F(1) + F(2)	|-- F(4) = F(2) + F(3)
													|-- F(3) = F(1) + F(2)
```



### 메모이제이션과 참조적 투명성

- **메모이제이션(memoization)**: 한 번 계산한 값을 저장해두었다가 재활용하는 것이다.
- **참조적 투명성(referential transparency)**: 입력값이 같다면 함수가 언제나 같은 반환값을 내는 것을 의미한다.
- 메모이제이션을 적용하기 위해서 함수는 참조적 투명성을 가져야 한다. 피보나치 수열을 계산할 때 `F(2)`를 저장해놓았다면 그 값이 언제나 같길 원할 것이다,



## 동적 계획법의 방법론

동적 계획법에서 계산한 결과를 저장하는 방법은 크게 두 가지가 있다.

1. 상향식(Bottom-up)
2. 하향식(Top-Down)



`피보나치 수열`을 예시로 한다.



### 상향식

- **상향식(bottom-up)**: 더 작은 하위 문제부터 계산한 후, 이 문제들의 계산 결과를 이용하여 더 큰 문제를 계산한다.
  - **타뷸레이션(tabulation)**이라고도 한다.
  - 반복문을 사용한다.
  - 함수 호출로 인한 오버헤드가 없다.

```python
def F(n):
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-2] + dp[i-1]
    return dp[n]
```



### 하향식

- **하향식(top-down)**: 더 큰 문제를 호출한 후, <u>하위 문제가 계산되었는지 확인하며</u> 문제를 계산한다.
  - **메모이제이션(memoization)**이라고도 한다.
  - 재귀를 사용한다.
  - 가독성이 좋으며, 본래의 점화식의 형태를 따르므로 자연스럽다.

```python
def F(n):
    if n <= 1:
        return n
    
    if dp[n]:
        return dp[n]
    
    dp[n] = F(n - 2) + F(n - 1)
    return dp[n]
```

