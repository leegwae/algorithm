# Bubble Sort

- **버블 정렬(Bubble Sort)**는 인접한 두 요소를 비교하여 정렬 기준대로 나열하며 정렬하는 알고리즘이다.



## 버블 정렬의 동작

오름차순을 기준으로 한다.

1. 탐색 배열에서 처음부터 순서대로 인접한 두 개의 요소를 비교하여 오름차순으로 정렬한다.
2. 탐색 배열의 마지막 요소를 제외한다.
3. 탐색 배열의 길이가 `1`이 될 때까지 반복한다.



## 버블 정렬의 구현

[bubble_sort.py](https://github.com/leegwae/problem-solving/blob/main/sorting/bubble_sort.py)

```python
def bubble_sort(arr):
    N = len(arr)
    for i in range(N-1, 0, -1):
        for j in range(0, i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```



## 개선된 버블 정렬

[구현된 버블 정렬](#버블-정렬의-구현)의 시간복잡도는 어느 경우에서도 `O(n^2)`이다. 그런데 아래와 같은 경우의 배열을 생각해보자.

```python
arr = [2, 1, 3, 4, 5, 6]
```

이 `arr`는 `[2, 1]`을 제외하면 정렬이 되어있다. `last = N - 1`일 때 내부 `for`문을 한 번 돌고 나면 다음과 같이 정렬이 완료될 것이다.

```python
arr = [1, 2, 3, 4, 5, 6]
```

이제부터 `arr`는 정렬이 완료된 상태이므로, 내부 `for`문을 돌아도 `arr[i] > arr[i + 1]`을 만족하지 않아 요소의 이동은 이루어지지 않을 것이다. 즉, 내부 `for`문을 돌 동안 교환이 일어나지 않는다면 이미 정렬된 것으로 볼 수 있다.

```python
def bubble_sort(arr):
    N = len(arr)
    for i in range(N-1, 0, -1):
        swapped = False
        for j in range(0, i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break
```

교환이 일어나는지 체크하는 플래그를 두어 시간 복잡도의 하한(이미 정렬되어 있는 경우)을 `O(n)`으로 개선할 수 있다.



## 버블 정렬의 복잡도

### 시간 복잡도

#### 개선 전

비교 횟수가 `(n - 1) + (n - 2) + ... + 1 = n(n-1) / 2`이므로 최선, 최악, 평균의 경우에서 시간 복잡도는 `O(n^2)`이다.

이동 횟수는 다음과 같다.

- 최악의 경우는 역순으로 정렬된 경우로 `3 * 비교횟수`번이다.
- 최선의 경우는 이미 정렬된 경우로 `0`번이다.
- 평균적으로는 `O(n^2)`이다.

#### 개선 후

- 최선의 경우는 이미 정렬된 경우로 `O(n)`이다.
- 최악의 경우, 평균의 경우 `O(n^2)`이다.

### 공간 복잡도

두 원소의 값을 바꾸기 위해 `O(1)`의 공간 복잡도를 필요로 한다.



## 버블 정렬의 특징

- 장점
  - 간단하다.
  - 안정 정렬이다.
  - 제자리 정렬이다.
- 단점
  - 비효율적이다.
  - 이동 횟수가 많다.